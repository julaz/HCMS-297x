/** \file hcms-297x.h - интерфейс библиотеки поддержки HCMS-29xx

 * \brief Макросы, константы, типы, переменные и функции библиотеки поддержки.

 * \par

 * Основные возможности библиотеки:

 * -# требуется всего 5 линий микроконтроллера

 * -# поддерживается программный или аппаратный SPI

 * -# поддерживаются модули всех типов - 4, 8 или 16 знакомест

 * -# используется минимум ОЗУ

 * \par

 * \par \author ARV \par

 * \note Для свободного использования без ограничений

 * \n Схема: см. datasheet

 * \n \date	27 нояб. 2016 г.

 * \par

 * \version 0.01	\par

 * Copyright 2015 © ARV. All rights reserved.

 * \par

 * Для компиляции требуется:\n

 * 	-# WinAVR-20100110 или более новая версия

 *

 */



#ifndef HCMS_297X_H_

#define HCMS_297X_H_



#include <avr/io.h>

#include <stdint.h>



/// если для вывода на индикаторы не задействуется аппаратный SPI,

/// надо заремарить этот макрос (время обновления дисплея возрастет в 5 раз)

#define USE_SPI



/// если курсор не нужен - заремарить этот макрос.

/// увы, курсор не мигает - просто инверсия знакоместа

//#define USE_CURSOR



/// количество неависимых индикаторов

#define		CHIP_CNT		2

/// количество знакомест на 1 индикаторе

#define		CHIP_POS		8

/// количество столбцов в знакоместе (менять не следует)

#define 	FONT_COLS		5

/// количество символов, умещающихся на дисплее

#define		SCR_SIZE		(CHIP_CNT*CHIP_POS)

/// количество байт в массиве знакомест

#define		CHIP_RAW_SIZE	(CHIP_CNT*CHIP_POS*FONT_COLS)



/// если все линии управления на 1 порту - нужно описать его,

/// иначе макрос заремарить !

#define		ONE_PORT		D



// далее идет описание портов и пинов для управления чипом

// номер пина - это номер бита в порту, т.е. число от 0 до 7

/// порт выбора кристалла

#define		PORT_CE			ONE_PORT

/// пин выбора кристалла

#define		PIN_CE			1



/// порт выбора регистра

#define		PORT_RS			ONE_PORT

/// пин выбора регистра

#define		PIN_RS			3



/// порт сброса

#define		PORT_RST		ONE_PORT

/// пин сброса

#define		PIN_RST			0



#if !defined(USE_SPI)

// если не используется аппаратный SPI, следует дополнительно определить

/// порт синхронизации

#	define	PORT_CLK		ONE_PORT

/// пин синхронизации

#	define	PIN_CLK			2



/// порт последовательного вывода данных

#	define	PORT_DI			ONE_PORT

/// пин последовательного вывода данных

#	define	PIN_DI			4

#endif



/// задержка в миллисекундах при анимированном выводе строк

#define ANIMATE_DELAY_MS	10



/// константы для управления яркостью

typedef enum{				// real pwm

	PWM_BRIGHT_000	= 0,	// 0.0%

	PWM_BRIGHT_002	= 1,	// 1.7%

	PWM_BRIGHT_003	= 2, 	// 2.2%

	PWM_BRIGHT_005	= 3, 	// 5.0%

	PWM_BRIGHT_007	= 4, 	// 6.7%

	PWM_BRIGHT_008	= 5, 	// 8.3%

	PWM_BRIGHT_012	= 6, 	// 11.7%

	PWM_BRIGHT_015	= 7, 	// 15%

	PWM_BRIGHT_018	= 8, 	// 18%

	PWM_BRIGHT_023	= 9, 	// 23%

	PWM_BRIGHT_030	= 10,	// 30%

	PWM_BRIGHT_037	= 11,	// 37%

	PWM_BRIGHT_047	= 12,	// 47%

	PWM_BRIGHT_060	= 13,	// 60%

	PWM_BRIGHT_080	= 14,	// 80%

	PWM_PRIGHT_100	= 15 	// 100%

} pwm_brightness_t;



/// минимально разумная яркость

#define MIN_BRIGHTNESS		PWM_BRIGHT_002

/// максимально допустимая яркость

#define MAX_BRIGHTNESS		PWM_PRIGHT_100

/// яркость по умолчанию

#define DEFAULT_BRIGHTNESS	PWM_BRIGHT_047



/// константы для управления пиковым током

typedef enum{				// real peak current

	PEAK_04_MA		= 2,	//  4.0 mA

	PEAK_06_MA		= 1,	//  6.4 mA

	PEAK_09_MA		= 0,	//  9.3 mA

	PEAK_13_MA		= 3		// 12.8 mA

} peak_current_t;



/// пиковый ток по умолчанию

#define DEFAULT_PEAK_CURRENT	PEAK_09_MA



/// структура 0-го регистра управления

typedef	union{

	struct{

		pwm_brightness_t

				brightness		: 4;	/// яркость

		peak_current_t

				peak_current	: 2;	/// пиковый ток

		uint8_t	sleep_mode		: 1;	/// режим сна

		uint8_t reg				: 1;	/// номер регистра (должен быть 0)

	};

	uint8_t		byte;					/// доступ к регистру, как 1 байту

} ctrl_reg0_t;



/// структура 1-го регистра управления

typedef	union{

	struct{

		uint8_t	data_out_ctrl	: 1;	/// последовательный или параллельный режим DOUT

		uint8_t	edo_prescaler	: 1;	/// предделитель внешнего тактовго генератора

		uint8_t	reserved		: 5;	/// не изменять никогда!

		uint8_t	reg				: 1;	/// номер регистра (должен быть 1)

	};

	uint8_t		byte;					/// доступ к регистру, как 1 байту

} ctrl_reg1_t;



// вспомогательный тип для экономии памяти и кода

#if (CHIP_RAW_SIZE > UINT8_MAX)

#define buf_size_t	uint16_t

#else

#define buf_size_t	uint8_t

#endif



/// экранный символьный буффер

extern char hcms_screen[SCR_SIZE];



/// очистка дисплея

void hcms_clrscr(void);



#if defined(USE_CURSOR)

/// макрос скрытия курсора с дисплея

#define NO_CURSOR	(SCR_SIZE+1)

/** установка позиции курсора

 * чтобы убрать курсор, надо использовать #NO_CURSOR

 * @param pos позиция курсора на дисплее, начиная с 0

 */

void hcms_cursor_pos(uint8_t pos);

#endif



/** вывод строки на дисплей

 * всегда выводится не больше символов, чем умещается на дисплее. если строка

 * короче, то оставшееся место дисплея очищается.

 * @param s выводимая строка

 */

void hcms_puts(char *s);



/** вывод строки из flash на дисплей

 * символы, не влезающие на дисплей, отбрасываются, если строка короткая,

 * то свободное место на дисплее очищается

 * @param s строка во flash

 */

void hcms_puts_P(const char *s);



/** обновление дисплея

 * копирует содержимое экранного буфера на дисплей

 */

void hcms_update_scr(void);



/** установка яркости дисплея

 *

 * @param br уровень яркости

 */

void hcms_bright(pwm_brightness_t br);



/** установка пикового тока сегмента

 *

 * @param pc уровень пиковго тока

 */

void hcms_peak_current(peak_current_t pc);



/** включение/отключение дисплея

 * при выключении переводит дисплей в режим sleep.

 * @param on ноль - выключить, не ноль - включить дисплей

 */

void hcms_on(uint8_t on);



/** вывод строки с эффектом всплывания или опскания

 * строка на дисплее заменяется выводимой строкой с эффектом всплывания или

 * погружения символов.

 * @param s новая строка

 * @param up направление эффекта (0 или менее - вниз, иначе вверх)

 */

void hcms_rollower_puts(char *s, int8_t delta);



/** вывод строки с эффектом последовательного всплытия или опускания

 * в отличие от #hcms_rollover_puts эта функция осуществляет не одновременное

 * всплытие/опускание всех символов строки, а последовательное: каждый

 * следующий символ начинает движение с запаздыванием в одну строку

 * @param s выводимая строка

 * @param up направение (0 или менее - вниз, иначе - вверх)

 */

void hcms_smooth_rollower_puts(char *s, int8_t up);



// нижний уровень управления дисплеем

/** вывод данных на дисплей

 * выводит заданное количество байтов на дисплей.

 * @param buf указатель на данные

 * @param sz количество выводимых байтов

 */

void hcms_raw_pixels(uint8_t *buf, buf_size_t sz);



#endif /* HCMS_297X_H_ */

