https://simple-devices.ru/articles/7-soft/233-support-c-code-for-hcms-29xx

Я применил имеющуюся у меня atmega32, хотя на схеме показан совсем иной микроконтроллер. Но главное в этой схеме - это правильно соединить между собой сами индикаторы, а эту задачу предлагаемая схема решает. Так как индикаторы используют последовательный ввод данных, линию DATA IN к микроконтролеру следует подключать только от самого правого индикатора, а более левые получают данные из DATA OUT предыдущего. Все остальные линии всех индикаторов - RS, CE, CLOCK и RESET следует соединить параллельно и подключить к любым свободным выводам микроконтроллера.

Теперь следует открыть файл hcms_297x.h и отредактировать его в соответствии с вашими желаниями и/или намерениями. В этом файле все или почти все делается путем правки определенных макросов.

USE_SPI - макрос, который должен быть определен, если вы вознамерились использовать для работы с HCMS-2915 аппаратный SPI микроконтроллера. Если SPI уже занят, или задействованы его порты, этот макрос нужно обязательно заремарить или удалить вообще. Кстати, обмен через SPI примерно в 5 раз производительнее, чем без него - если вам важно быстродействие, подумайте об этом.

USE_CURSOR - макрос, наличие которого в файле обеспечит вам возможность использования курсора - это если вы хотите реализовать редактор или что-то в этом духе. Курсор, к сожалению, мигать не будет (если хотите - сделайте это сами с использоанием таймера). Если этот макрос определен, то автоматически становится доступным и функция управления позицией курсора на дисплее hcms_cursor_pos, а так же константа NO_CURSOR, передав которую в эту функцию вы сможете убрать курсор с дисплея. Если курсор вам в проекте не нужен - заремарьте макрос USE_CURSOR.

CHIP_CNT - это количество отдельных корпусов индикаторов, задействованных в вашем проекте. Например, в моем проекте (см. видео) задействовано 2 отдельных чипа индикаторов, и этот макрос равен 2. Если у вас иное количество чипов - обязательно задайте правильное их количество!

CHIP_POS - количество позиций на одном чипе индикатора. Выпускаются индикаторы с 4, 8 или 16 знакоместами, соответственно значение этого макроса должно быть задано корректно в соответствии с реально примененными индикаторами. В моём случае это 8.

Макрос FONT_COLS введен для удобства, менять его значение не следует. Он обозначает количество байт знакогенератора, определяющих "рисунок" одного символа. Иначе говоря, это количество столбцов в матрице пикселей одного знакоместа.

SCR_SIZE и CHIP_RAW_SIZE вычисляются автоматически на основе предыдущих макросов и обозначают количество знакомест на всем дисплее (дисплеем я называю все индикаторы в схеме) и размер буфера данных, которые отвечают за изображение на дисплее. Второй макрос можно использовать, если вы захотите рисовать что-то более сложное, нежели текст, на индикаторах. Кстати, в библиотеке ардуино, которая легко нагугливается, применяется массив именно такого размера, в то время как в моей библиотеке под экранную область требуется SCR_SIZE байтов, т.е. в 5 раз меньше.

Теперь переходим к описанию интерфейса связи с микроконтроллером.

ONE_PORT - этот макрос должен быть объявлен, если физически все 5 сигналов управления индикатором заведены на один порт микроконтроллера. Нужно всего лишь указать букву, обозначающую этот порт. Например, для PORTD надо указать D - и всего-то! Если линии управления разбросаны по портам произвольно, макрос ONE_PORT должен быть заремарен. Кстати, при использовании аппаратного SPI этот макрос относится только к трем линиям управления - RS, CE и RESET.

Ниже по тексту файла следуют определения макросов PORT_CE, PORT_RS, PORT_RST, а так же если не используется аппаратный SPI, то еще и PORT_CLK и PORT_DI. Макросы эти должны содержать либо букву порта, к которому подключена соответствующая линия управления, либо отсылку на "единственный" порт - ONE_PORT. 

Так же при помощи макросов PIN_CE, PIN_RS, PIN_RST (а без аппаратного SPI еще PIN_CLK и PIN_DI) следует указать номера битов порта, соответствующих каждому сигналу. 

То есть реализована возможность совершенно произвольно разместить сигналы по свободным портам микроконтроллера. Для случая применения SPI сигнал CLOCK (CLK) всегда берется с линии CLK аппаратного SPI микроконтроллера, а для синала DATA IN (DI) используется линия MOSI. Указывать номера битов и буквы портов для аппаратного SPI не нужно.

ANIMATE_DELAY_MS - этот макрос задает задержку в миллисекундах, которая используется при реализации анимаии в момент вывода строк на индикатор. Нужен он для функций hcms_rollower_puts и hcms_smooth_rollower_puts - если вы их не применяете, на этот макрос можете наплевать.

Далее вводятся некоторые типы данных, облегчающие работу с индикаторами.

pwm_brightness_t - тип-перечисление, определяющий значения яркости дисплея, которые можно задавать аппаратно. Для удобства дополнительно введены два макроса, обозначающих границы изменения яркости (например, если вы захотите менять ее в цикле): MIN_BRIGHTNESS и MAX_BRIGHTNESS. Макрос DEFAULT_BRIGHTNESS может быть использован для задания яркости, устанавливаемой сразу после инициализации модуля.

peak_current_t - тип-перечисление, определяющий варианты аппаратно задавемого ограничения пикового тока через 1 сегмент индикатора. Аналогично DEFAULT_PEAK_CURRENT задает уровень ограничения пикового тока сразу после инициализации.

ctrl_reg0_t и ctrl_reg1_t - это два "сложных" типа для работы с двумя регистрами управления индикаторов. Типы являются объединениями (union) структуры с битовыми полями и однобайтного значения, что позволяет программисту пользоваться значением регистра, как байтом (как в ардуино), так и значениями отдельных груп битов в этом байте. Назначение полей в структурах вы можете уточнить по даташиту на индикатор (я прилагаю его к статье).

buf_size_t - это тип для хранения размера буффера под "сырые" данные. Он введен с целью максимальной экономии ОЗУ под статические переменные библиотеки. Можно было бы, конечно, всегда использовать int, но тогда для одного индикатора с 8 позициями мы бы напрасно потеряли целый байт ОЗУ...

char hcms_screen[SCR_SIZE] - это массив "экранной области". Все функции вывода в этой библиотеке обязательно используют этот массив. Вы можете обновлять его и при помощи любых иных средств, например, при помощи функций sprintf - тогда после того, как обновите, обязательно вызовите функцию hcms_update_scr - и на индикаторе появится все то, что находится в экранной области.

Осталось рассмотреть функции библиотечки, и можно завершать...

void hcms_clrscr(void) - очищает дисплей и экранную область.

void hcms_cursor_pos(uint8_t pos) - изменяет положение позиции курсора на дисплее. Самая левая позиция соответствует 0.

void hcms_puts(char *s) - вывод строки на дисплей (и в экранную область). Строка выводится всегда с крайней левой позиции дисплея, если она целиком не влезает - остаток отбрасывается, если строка короче, чем дисплей - остальные позиции дисплея очищаются.

void hcms_puts_P(const char *s) то же самое, что и предыущая функция, но строка берется из flash.

void hcms_update_scr(void) - обновление дисплея. Вызывайте эту функцию всегда после того, как изменили содержимое экранной области.

void hcms_bright(pwm_brightness_t br) - изменение яркости индикатора. Просто передайте в эту функцию соответствющее значение из определенного в  pwm_brightness_t.

void hcms_peak_current(peak_current_t pc) - изменение уровня ограничения пикового тока через сегмент.

void hcms_on(uint8_t on) - включение или отключение дисплея. Если передать в эту функцию параметр 0, дисплей перейдет в спящий режим.

void hcms_rollower_puts(char *s, int8_t delta)
void hcms_smooth_rollower_puts(char *s, int8_t up) - эти две функции реализуют красивый вывод строки на дисплей. Каждая не просто затирает содержимое экранной области, как hcms_puts, а делает это путем "выталкивания" новым символом старого. На видео вы можете видеть работу именно этой пары: тектовые строки выводятся второй функцией, а смена показаний "одометра" - первой.

void hcms_raw_pixels(uint8_t *buf, buf_size_t sz) - эта функция просто последовательно выведет указанное количесвто байтов из указанного буфера на индикаторы. Что в итоге вы увидите, зависит от того, насколько тщятельно вы изучили даташит и подготовили содержимое массива...

Чтобы собрать свой проект с моей библиотечкой, вы должны добавить hcms_297x.h в модуль, где будете пользоваться функциями из библиотечки, а файл hcms_297x.c добавить в список компилируемых файлов вашего проекта. В папке проекта так же должен находиться и файл font7x5.h. Обратите внимание, что не надо предпринимать какие-то шаги по инициализации аппаратной периферии микроконтроллера, задействованной в библиотечке - настраивать порты, SPI и т.п. Все делается автоматически, просто берите и выводите на индикаторы то, что вам нужно.

Вот и все. Надеюсь, кому-то это пригодится.

P.S. Я не стал изобретать велосипед и просто использовал знакогенератор из нагугленной библиотечки для ардуино. Но небольшие изменения в него я все-таки сделал - несущественные. Если нужно выводить кириллицу, вам придется "нарисовать" знакогенератор русских символов самостоятельно по образу и подобию имеющегося.

P.P.S. В прилагаемом архиве с библиотечкой есть файл avr_helper.h - он подключается к библиотеке, как системный. Я рекомендую пометсить его в "системную" библиотеку куомпилятора.
